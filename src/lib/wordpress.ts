import axios from 'axios';
import { decodeHtmlEntitiesServer } from '@/utils/htmlDecode';
import { cleanWordPressContent } from '@/utils/wordpressContent';
import { getWooCommerceCoursePrices, wooCommercePricesCache } from './tutor-lms';

const WORDPRESS_URL = process.env.NEXT_PUBLIC_WORDPRESS_URL || 'https://api.helvetiforma.ch';

// Types pour les articles WordPress
export interface WordPressPost {
  _id: number;
  title: string;
  slug: string | { current: string };
  excerpt: string;
  body: string;
  publishedAt: string;
  accessLevel: 'public' | 'members' | 'premium';
  price: number;
  image: string | null;
  category: string | null;
  tags: string[];
  // Propri√©t√©s additionnelles pour compatibilit√©
  created_at?: string;
  updated_at?: string;
  featured_image?: string;
  content?: string;
  // M√©tadonn√©es ACF et WordPress
  acf?: any;
  meta?: any;
  // Donn√©es WooCommerce
  woocommerce?: any;
}

// Client WordPress standard (avec cookies pour les sessions)
export const wordpressClient = axios.create({
  baseURL: `${WORDPRESS_URL}/wp-json`,
  headers: {
    'Content-Type': 'application/json',
  },
  withCredentials: true, // Important: permet l'envoi des cookies de session
});

// Client WooCommerce (avec authentification)
export const woocommerceClient = axios.create({
  baseURL: `${WORDPRESS_URL}/wp-json`,
  headers: {
    'Content-Type': 'application/json',
  },
  auth: {
    username: process.env.WOOCOMMERCE_CONSUMER_KEY || '',
    password: process.env.WOOCOMMERCE_CONSUMER_SECRET || ''
  }
});

// Client authentifi√©
export const wordpressAuthClient = (token: string) => axios.create({
  baseURL: `${WORDPRESS_URL}/wp-json`,
  headers: {
    'Content-Type': 'application/json',
    'Authorization': `Bearer ${token}`,
  },
});

// R√©cup√©rer tous les articles
export async function getWordPressPosts(): Promise<WordPressPost[]> {
  try {
    console.log('üîç R√©cup√©ration des articles WordPress...');
    
    // Utiliser l'API WordPress standard au lieu de l'endpoint personnalis√©
    const response = await wordpressClient.get('/wp/v2/posts', {
      params: {
        per_page: 100, // R√©cup√©rer jusqu'√† 100 articles
        status: 'publish' // Seulement les articles publi√©s
      }
    });
    
    console.log(`‚úÖ ${response.data.length} articles r√©cup√©r√©s depuis WordPress`);
    
    // Formater les articles selon notre interface
    const formattedPosts = await Promise.all(
      response.data.map((post: any) => formatWordPressPost(post))
    );
    
    console.log(`‚úÖ ${formattedPosts.length} articles format√©s avec succ√®s`);
    return formattedPosts;
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration articles WordPress:', error);
    return [];
  }
}

// Formater un article WordPress selon notre interface
async function formatWordPressPost(post: any): Promise<WordPressPost> {
  console.log('üîç formatWordPressPost - D√©but traitement article:', post.id, post.title?.rendered);
  
  // D√©terminer le prix depuis ACF d'abord
  let price = 0;
  if (post.acf?.price) {
    price = parseFloat(post.acf.price);
    console.log('üîç Prix ACF trouv√©:', price);
  }

  // R√©cup√©rer l'image featured
  let featuredImageUrl = null;
  if (post.featured_media) {
    try {
      featuredImageUrl = await getFeaturedImageUrl(post.featured_media);
      console.log('üîç Image featured r√©cup√©r√©e:', featuredImageUrl);
    } catch (error) {
      console.error('‚ùå Erreur r√©cup√©ration image featured:', error);
    }
  }

  // Formater l'article selon notre interface (sans WooCommerce pour l'instant)
  const decodedBody = decodeHtmlEntitiesServer(post.content.rendered)
  console.log('üîç Contenu avant nettoyage (premiers 200 caract√®res):', decodedBody.substring(0, 200));
  
  const cleanedBody = cleanWordPressContent(decodedBody)
  console.log('üîç Contenu apr√®s nettoyage (premiers 200 caract√®res):', cleanedBody.substring(0, 200));
  
  // R√©cup√©rer les PDFs depuis le champ ACF
  const pdfAttachments = await extractPdfsFromACF(post.acf);
  console.log('üîç PDFs r√©cup√©r√©s depuis ACF:', pdfAttachments.length);
  
  // Nettoyer aussi l'extrait pour supprimer les balises <p>
  const decodedExcerpt = decodeHtmlEntitiesServer(post.excerpt.rendered);
  const cleanedExcerpt = cleanWordPressContent(decodedExcerpt);
  
  const formattedPost = {
    _id: post.id,
    title: decodeHtmlEntitiesServer(post.title.rendered),
    slug: post.slug,
    excerpt: cleanedExcerpt,
    body: cleanedBody,
    publishedAt: post.date,
    accessLevel: post.acf?.access_level || post.acf?.access || 'public',
    price: price,
    image: featuredImageUrl,
    featured_image: featuredImageUrl || undefined,
    category: post.categories?.[0] ? 'Category' : null,
    tags: post.tags || [],
    pdfAttachments: pdfAttachments, // Ajouter les PDFs extraits
    // Ajouter les m√©tadonn√©es ACF et meta
    acf: post.acf || {},
    meta: post.meta || {},
    // WooCommerce sera ajout√© plus tard si n√©cessaire
    woocommerce: null
  };

  console.log('‚úÖ formatWordPressPost - Article format√©:', formattedPost.title, 'Prix:', formattedPost.price, 'Image:', formattedPost.image, 'PDFs:', pdfAttachments.length);
  return formattedPost;
}

// Fonction pour extraire les PDFs depuis le champ ACF
async function extractPdfsFromACF(acf: any): Promise<Array<{
  title: string;
  url: string;
  isPremium: boolean;
  fileSize?: string;
  description?: string;
}>> {
  if (!acf) {
    console.log('üîç Aucune donn√©e ACF trouv√©e');
    return [];
  }

  const pdfs: Array<{
    title: string;
    url: string;
    isPremium: boolean;
    fileSize?: string;
    description?: string;
  }> = [];

  // V√©rifier le champ pdf (ID du fichier)
  if (acf.pdf && typeof acf.pdf === 'number') {
    console.log('üîç PDF ID trouv√© dans ACF:', acf.pdf);
    
    try {
      // R√©cup√©rer les d√©tails du fichier depuis l'API WordPress
      const response = await wordpressClient.get(`/wp/v2/media/${acf.pdf}`);
      const mediaData = response.data;
      
      if (mediaData && mediaData.source_url) {
        const filename = mediaData.filename || mediaData.title?.rendered || 'Document PDF';
        const title = filename.replace(/\.pdf$/i, '');
        
        // Calculer la taille du fichier
        let fileSize = '';
        if (mediaData.media_details && mediaData.media_details.filesize) {
          const bytes = mediaData.media_details.filesize;
          if (bytes > 1024 * 1024) {
            fileSize = `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
          } else if (bytes > 1024) {
            fileSize = `${(bytes / 1024).toFixed(1)} KB`;
          } else {
            fileSize = `${bytes} B`;
          }
        }
        
        pdfs.push({
          title: title,
          url: mediaData.source_url,
          isPremium: true, // Par d√©faut, tous les PDFs ACF sont premium
          fileSize: fileSize,
          description: `Document PDF: ${title}`
        });
        
        console.log('üîç PDF ACF ajout√©:', { title, url: mediaData.source_url, fileSize });
      }
    } catch (error) {
      console.error('‚ùå Erreur r√©cup√©ration d√©tails PDF:', error);
    }
  }

  // V√©rifier le champ pdf_attachments (nouveau format)
  if (acf.pdf_attachments && Array.isArray(acf.pdf_attachments)) {
    console.log('üîç Champ pdf_attachments trouv√©:', acf.pdf_attachments.length, '√©l√©ments');
    
    for (const pdf of acf.pdf_attachments) {
      if (pdf.pdf_file && pdf.pdf_file.url) {
        const title = pdf.pdf_title || pdf.title || 'Document PDF';
        const description = pdf.pdf_description || pdf.description || `Document PDF: ${title}`;
        
        let fileSize = '';
        if (pdf.pdf_file.filesize) {
          const bytes = pdf.pdf_file.filesize;
          if (bytes > 1024 * 1024) {
            fileSize = `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
          } else if (bytes > 1024) {
            fileSize = `${(bytes / 1024).toFixed(1)} KB`;
          } else {
            fileSize = `${bytes} B`;
          }
        }
        
        const isPremium = pdf.is_premium === true || pdf.is_premium === '1' || pdf.is_premium === 1;
        
        pdfs.push({
          title: title,
          url: pdf.pdf_file.url,
          isPremium: isPremium,
          fileSize: fileSize,
          description: description
        });
        
        console.log('üîç PDF ACF ajout√©:', { title, url: pdf.pdf_file.url, isPremium, fileSize });
      }
    }
  }

  console.log('üîç PDFs ACF extraits:', pdfs.length, pdfs.map(p => p.title));
  return pdfs;
}

// R√©cup√©rer un article par slug
export async function getWordPressPost(slug: string): Promise<WordPressPost | null> {
  try {
    // D'abord, essayer de r√©cup√©rer par slug via l'API WordPress standard
    const response = await wordpressClient.get(`/wp/v2/posts`, {
      params: {
        slug: slug,
        per_page: 1
      }
    });
    
    if (response.data && response.data.length > 0) {
      const post = response.data[0];
      return await formatWordPressPost(post);
    }
    
    return null;
  } catch (error) {
    console.error('Erreur r√©cup√©ration article WordPress:', error);
    return null;
  }
}

// R√©cup√©rer un article par ID
export async function getWordPressPostById(id: string | number): Promise<WordPressPost | null> {
  try {
    console.log('üîç R√©cup√©ration article WordPress par ID:', id, typeof id);
    
    // Validation de l'ID
    if (!id || id === 'undefined' || id === 'null' || id === '') {
      console.error('‚ùå ID invalide fourni:', id);
      return null;
    }
    
    // V√©rifier si c'est un ID num√©rique ou un slug
    const isNumericId = !isNaN(Number(id)) && Number(id) > 0;
    
    if (isNumericId) {
      // Essayer par ID num√©rique avec l'API WordPress native
      try {
        console.log('üîÑ Tentative par ID num√©rique...');
        const url = `/wp/v2/posts/${id}`;
        console.log('üîç URL de requ√™te:', url);
        console.log('üîç Base URL:', wordpressClient.defaults.baseURL);
        console.log('üîç URL compl√®te:', `${wordpressClient.defaults.baseURL}${url}`);
        
        const response = await wordpressClient.get(url);
        const post = response.data;
        
        console.log('üîç R√©ponse WordPress:', {
          status: response.status,
          data: post,
          title: post?.title?.rendered
        });
        
        if (post) {
          console.log('‚úÖ Article WordPress trouv√© par ID:', post.title?.rendered || 'Sans titre');
          return await formatWordPressPost(post);
        }
      } catch (idError: any) {
        console.log('‚ö†Ô∏è Article non trouv√© par ID num√©rique, tentative par slug...', {
          message: idError.message,
          status: idError.response?.status,
          data: idError.response?.data,
          url: idError.config?.url
        });
      }
    }
    
    // Essayer par slug avec l'API WordPress native
    try {
      console.log('üîÑ Tentative par slug...');
      const slugResponse = await wordpressClient.get('/wp/v2/posts', {
        params: { slug: id, per_page: 1 }
      });
      
      console.log('üîç Slug response:', {
        status: slugResponse.status,
        dataLength: slugResponse.data?.length,
        data: slugResponse.data
      });
      
      if (slugResponse.data && slugResponse.data.length > 0) {
        console.log('‚úÖ Article trouv√© par slug:', slugResponse.data[0].title?.rendered);
        const formattedPost = await formatWordPressPost(slugResponse.data[0]);
        console.log('üîç Formatted post:', formattedPost);
        return formattedPost;
      } else {
        console.log('‚ö†Ô∏è Aucun article trouv√© par slug dans la r√©ponse');
      }
    } catch (slugError: any) {
      console.log('‚ö†Ô∏è Erreur lors de la recherche par slug:', {
        message: slugError.message,
        status: slugError.response?.status,
        data: slugError.response?.data
      });
    }
    
    // Derni√®re tentative: r√©cup√©rer tous les articles et chercher localement
    try {
      console.log('üîÑ Tentative avec r√©cup√©ration de tous les articles...');
      const response = await wordpressClient.get('/wp/v2/posts', {
        params: { per_page: 100, status: 'publish' }
      });
      const posts = response.data;
      
      if (posts && Array.isArray(posts)) {
        // Chercher par ID num√©rique ou par slug
        const isNumericId = !isNaN(Number(id)) && Number(id) > 0;
        let foundPost = null;
        
        if (isNumericId) {
          foundPost = posts.find((post: any) => post.id === Number(id));
        } else {
          foundPost = posts.find((post: any) => post.slug === id);
        }
        
        if (foundPost) {
          console.log('‚úÖ Article trouv√© via recherche globale:', foundPost.title?.rendered || 'Sans titre');
          return await formatWordPressPost(foundPost);
        }
      }
    } catch (globalError: any) {
      console.log('‚ö†Ô∏è Recherche globale √©chou√©e:', {
        message: globalError.message,
        status: globalError.response?.status
      });
    }
    
    console.error('‚ùå Article non trouv√© ni par ID ni par slug:', id);
    return null;
    
  } catch (error: any) {
    console.error('‚ùå Erreur r√©cup√©ration article WordPress:', {
      id,
      message: error.message,
      status: error.response?.status,
      data: error.response?.data,
      code: error.code,
      url: error.config?.url,
      baseURL: error.config?.baseURL,
      fullError: error
    });
    return null;
  }
}

// Alias pour compatibilit√©
export const getWordPressPostBySlug = getWordPressPost;

// Helper function to get featured image URL
async function getFeaturedImageUrl(mediaId: number): Promise<string | null> {
  try {
    const response = await wordpressClient.get(`/wp/v2/media/${mediaId}`);
    if (response.data && response.data.source_url) {
      // Use proxy-image API to avoid CORS issues
      const imageUrl = response.data.source_url;
      return `/api/proxy-image?url=${encodeURIComponent(imageUrl)}`;
    }
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration image featured:', error);
  }
  return null;
}

// Helper function to get slug string from WordPress post
export function getPostSlug(post: WordPressPost): string {
  return typeof post.slug === 'string' ? post.slug : post.slug?.current || '';
}

// V√©rifier achat utilisateur via WooCommerce
export async function checkWordPressPurchase(userId: string, postId: string): Promise<boolean> {
  try {
    console.log('üîç checkWordPressPurchase called with:', { userId, postId })
    
    // R√©cup√©rer les commandes de l'utilisateur
    const orders = await getWordPressUserPurchases(userId);
    console.log('üîç WooCommerce orders found:', orders.length);
    
    // V√©rifier si une commande contient l'article sp√©cifique
    const hasPurchased = orders.some((order: any) =>
      order.line_items.some((item: any) => {
        // V√©rifier si l'ID de l'article est dans les m√©tadonn√©es de la ligne de commande
        const postIdMeta = item.meta_data?.find((meta: any) => meta.key === '_post_id')
        if (postIdMeta && postIdMeta.value === postId) {
          return true
        }
        // V√©rifier si l'ID de l'article est dans le SKU (format: article-{id})
        if (item.sku === `article-${postId}`) {
          return true
        }
        return false
      })
    );
    
    console.log('üîç Purchase check result:', { hasPurchased, userId, postId });
    return hasPurchased;
  } catch (error) {
    console.error('Erreur v√©rification achat WordPress:', error);
    return false;
  }
}

// R√©cup√©rer les achats d'un utilisateur via WooCommerce
export async function getWordPressUserPurchases(userId: string): Promise<any[]> {
  try {
    console.log('üîç R√©cup√©ration des achats pour l\'utilisateur:', userId);
    
    // R√©cup√©rer toutes les commandes compl√©t√©es
    const response = await woocommerceClient.get('/wc/v3/orders', {
      params: {
        status: 'completed',
        per_page: 100
      }
    });
    
    const allOrders = response.data || [];
    console.log(`üì¶ ${allOrders.length} commandes totales trouv√©es`);
    
    // Filtrer les commandes qui appartiennent √† cet utilisateur
    const userOrders = allOrders.filter((order: any) => {
      // V√©rifier par customer_id si c'est un ID num√©rique
      if (!isNaN(Number(userId)) && order.customer_id === Number(userId)) {
        return true;
      }
      
      // V√©rifier par email dans billing
      if (order.billing?.email === userId) {
        return true;
      }
      
      // V√©rifier par _user_id dans les m√©tadonn√©es
      const userIdMeta = order.meta_data?.find((meta: any) => meta.key === '_user_id');
      if (userIdMeta && userIdMeta.value === userId) {
        return true;
      }
      
      return false;
    });
    
    console.log(`‚úÖ ${userOrders.length} commandes trouv√©es pour l'utilisateur ${userId}`);
    
    return userOrders;
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration achats WordPress:', error);
    return [];
  }
}

// R√©cup√©rer les articles achet√©s par un utilisateur avec d√©tails
export async function getUserPurchasedArticles(userId: string): Promise<WordPressPost[]> {
  try {
    console.log('üîç R√©cup√©ration des articles achet√©s pour l\'utilisateur:', userId);
    
    // R√©cup√©rer les commandes de l'utilisateur
    const orders = await getWordPressUserPurchases(userId);
    
    if (orders.length === 0) {
      console.log('‚ÑπÔ∏è Aucune commande trouv√©e pour l\'utilisateur');
      return [];
    }
    
    // Extraire les IDs d'articles des commandes
    const articleIds = new Set<string>();
    
    for (const order of orders) {
      if (order.line_items && Array.isArray(order.line_items)) {
        for (const item of order.line_items) {
          // Chercher dans les m√©tadonn√©es pour l'ID de l'article
          if (item.meta_data) {
            const postIdMeta = item.meta_data.find((meta: any) => meta.key === '_post_id');
            if (postIdMeta && postIdMeta.value) {
              articleIds.add(postIdMeta.value.toString());
            }
          }
          
          // Aussi v√©rifier le SKU pour les articles (format: article-{id})
          if (item.sku && item.sku.startsWith('article-')) {
            const postId = item.sku.replace('article-', '');
            articleIds.add(postId);
          }
        }
      }
    }
    
    console.log(`üìö ${articleIds.size} articles uniques trouv√©s dans les commandes`);
    
    // R√©cup√©rer les d√©tails de chaque article
    const articles: WordPressPost[] = [];
    
    for (const articleId of articleIds) {
      try {
        const article = await getWordPressPostById(articleId);
        if (article) {
          articles.push(article);
        }
      } catch (error) {
        console.error(`‚ùå Erreur r√©cup√©ration article ${articleId}:`, error);
      }
    }
    
    console.log(`‚úÖ ${articles.length} articles r√©cup√©r√©s avec succ√®s`);
    return articles;
    
  } catch (error) {
    console.error('‚ùå Erreur r√©cup√©ration articles achet√©s:', error);
    return [];
  }
}

// WordPress Courses API Functions
export async function getWordPressCourses(params: {
  per_page?: number;
  page?: number;
  search?: string;
  category?: string;
  level?: string;
  status?: 'publish' | 'draft' | 'private';
  featured?: boolean;
} = {}): Promise<any[]> {
  try {
    console.log('üîç Fetching courses from WordPress API...');
    
    const response = await wordpressClient.get('/wp/v2/courses', {
      params: {
        per_page: params.per_page || 50,
        page: params.page || 1,
        search: params.search,
        status: params.status || 'publish',
        _embed: true, // Include embedded resources like featured images
        ...(params.category && { 'course-category': params.category }),
        ...(params.level && { 'course-tag': params.level }),
        ...(params.featured && { featured: true })
      }
    });
    
    console.log('‚úÖ WordPress API response:', response.status, response.data?.length || 0, 'courses');
    return response.data || [];
    
  } catch (error) {
    console.error('‚ùå Error fetching WordPress courses:', error);
    return [];
  }
}

// Format WordPress course data to match TutorCourse interface
export function formatWordPressCourse(course: any): any {
  // Get featured image URL from embedded media
  let featuredImage = '';
  if (course._embedded && course._embedded['wp:featuredmedia'] && course._embedded['wp:featuredmedia'][0]) {
    const media = course._embedded['wp:featuredmedia'][0];
    featuredImage = media.source_url || media.media_details?.sizes?.large?.source_url || media.media_details?.sizes?.medium?.source_url || '';
  }

  // Get categories from embedded terms
  let categories: any[] = [];
  if (course._embedded && course._embedded['wp:term']) {
    const terms = course._embedded['wp:term'];
    categories = terms.flat().filter((term: any) => term.taxonomy === 'course-category');
  }

  // Get tags from embedded terms
  let tags: any[] = [];
  if (course._embedded && course._embedded['wp:term']) {
    const terms = course._embedded['wp:term'];
    tags = terms.flat().filter((term: any) => term.taxonomy === 'course-tag');
  }

  // Clean HTML from text fields
  const cleanHtmlText = (text: string) => {
    if (!text) return '';
    return text.replace(/<[^>]*>/g, '').replace(/&[^;]+;/g, ' ').trim();
  };

  return {
    id: course.id,
    title: cleanHtmlText(course.title?.rendered || course.title || ''),
    content: course.content?.rendered || course.content || '',
    excerpt: cleanHtmlText(course.excerpt?.rendered || course.excerpt || ''),
    slug: course.slug,
    status: course.status || 'publish',
    author: course.author || 0,
    featured_image: featuredImage,
    course_price: 0, // Will be set by WooCommerce integration
    course_level: 'beginner', // Default level
    course_duration: '',
    course_benefits: [],
    course_requirements: [],
    course_curriculum: [],
    course_instructors: [],
    enrolled_count: 0,
    rating: 0,
    reviews_count: 0,
    is_enrolled: false,
    is_completed: false,
    progress_percentage: 0,
    created_at: course.date || new Date().toISOString(),
    updated_at: course.modified || new Date().toISOString(),
    categories: categories,
    tags: tags,
  };
}

export async function getWordPressCourse(courseId: string | number): Promise<any | null> {
  try {
    console.log('üîç Fetching course from WordPress API:', courseId);
    
    const response = await wordpressClient.get(`/wp/v2/courses/${courseId}`, {
      params: { _embed: true }
    });
    
    console.log('‚úÖ WordPress API course response:', response.status);
    return response.data;
    
  } catch (error) {
    console.error('‚ùå Error fetching WordPress course:', error);
    return null;
  }
}

// Complete WordPress courses function with WooCommerce integration
export async function getWordPressCoursesWithPrices(params: {
  per_page?: number;
  page?: number;
  search?: string;
  category?: string;
  level?: string;
  status?: 'publish' | 'draft' | 'private';
  featured?: boolean;
} = {}): Promise<any[]> {
  try {
    console.log('üîç Fetching courses from WordPress API with prices...');
    
    // Fetch courses from WordPress
    const courses = await getWordPressCourses(params);
    
    if (courses.length === 0) {
      console.log('üìö No courses found from WordPress API');
      return [];
    }
    
    // Fetch WooCommerce prices
    console.log('üí∞ Fetching WooCommerce prices...');
    await getWooCommerceCoursePrices();
    
    // Format courses with prices
    console.log('üîÑ Processing courses with prices...');
    const formattedCourses = courses.map(course => {
      const formatted = formatWordPressCourse(course);
      
      // Add WooCommerce price if available
      const title = formatted.title.toLowerCase();
      const slug = formatted.slug;
      
      if (wooCommercePricesCache[title]) {
        formatted.course_price = wooCommercePricesCache[title];
      } else if (wooCommercePricesCache[slug]) {
        formatted.course_price = wooCommercePricesCache[slug];
      }
      
      return formatted;
    });
    
    console.log('‚úÖ WordPress courses processed:', formattedCourses.length);
    return formattedCourses;
    
  } catch (error) {
    console.error('‚ùå Error fetching WordPress courses with prices:', error);
    return [];
  }
}

// Fonctions TutorLMS (placeholders - kept for compatibility)
export async function getTutorCourses() {
  try {
    const response = await wordpressClient.get('/tutor/v1/courses');
    return response.data;
  } catch (error) {
    console.error('Erreur r√©cup√©ration cours TutorLMS:', error);
    return [];
  }
}

export async function getTutorCourse(courseId: string) {
  try {
    const response = await wordpressClient.get(`/tutor/v1/courses/${courseId}`);
    return response.data;
  } catch (error) {
    console.error('Erreur r√©cup√©ration cours TutorLMS:', error);
    return null;
  }
}